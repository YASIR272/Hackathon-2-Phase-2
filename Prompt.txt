
"""Yeh pore project ko sahi se read karo: """

Phase II: Todo Full-Stack Web Application
Basic Level Functionality
Objective: Using Claude Code and Spec-Kit Plus transform the console app into a modern multi-user web application with persistent storage.
üí°Development Approach: Use the Agentic Dev Stack workflow: Write spec ‚Üí Generate plan ‚Üí Break into tasks ‚Üí Implement via Claude Code. No manual coding allowed. We will review the process, prompts, and iterations to judge each phase and project.
Requirements
Implement all 5 Basic Level features as a web application
Create RESTful API endpoints
Build responsive frontend interface
Store data in Neon Serverless PostgreSQL database
Authentication ‚Äì Implement user signup/signin using Better Auth
Technology Stack
Layer
Technology
Frontend
Next.js 16+ (App Router)
Backend
Python FastAPI
ORM
SQLModel
Database
Neon Serverless PostgreSQL
Spec-Driven
Claude Code + Spec-Kit Plus
Authentication
Better Auth

API Endpoints
Method
Endpoint
Description
GET
/api/{user_id}/tasks
List all tasks
POST
/api/{user_id}/tasks
Create a new task
GET
/api/{user_id}/tasks/{id}
Get task details
PUT
/api/{user_id}/tasks/{id}
Update a task
DELETE
/api/{user_id}tasks/{id}
Delete a task
PATCH
/api/{user_id}tasks/{id}/complete
Toggle completion


Securing the REST API
Better Auth + FastAPI Integration
The Challenge
Better Auth is a JavaScript/TypeScript authentication library that runs on your Next.js frontend. However, your FastAPI backend is a separate Python service that needs to verify which user is making API requests.
The Solution: JWT Tokens
Better Auth can be configured to issue JWT (JSON Web Token) tokens when users log in. These tokens are self-contained credentials that include user information and can be verified by any service that knows the secret key.
How It Works
User logs in on Frontend ‚Üí Better Auth creates a session and issues a JWT token
Frontend makes API call ‚Üí Includes the JWT token in the Authorization: Bearer <token> header
Backend receives request ‚Üí Extracts token from header, verifies signature using shared secret
Backend identifies user ‚Üí Decodes token to get user ID, email, etc. and matches it with the user ID in the URL
Backend filters data ‚Üí Returns only tasks belonging to that user
What Needs to Change
Component
Changes Required
Better Auth Config
Enable JWT plugin to issue tokens
Frontend API Client
Attach JWT token to every API request header
FastAPI Backend
Add middleware to verify JWT and extract user
API Routes
Filter all queries by the authenticated user's ID

The Shared Secret
Both frontend (Better Auth) and backend (FastAPI) must use the same secret key for JWT signing and verification. This is typically set via environment variable BETTER_AUTH_SECRET in both services.
Security Benefits
Benefit
Description
User Isolation
Each user only sees their own tasks
Stateless Auth
Backend doesn't need to call frontend to verify users
Token Expiry
JWTs expire automatically (e.g., after 7 days)
No Shared DB Session
Frontend and backend can verify auth independently

API Behavior Change
After Auth:
All endpoints require valid JWT token
Requests without token receive 401 Unauthorized
Each user only sees/modifies their own tasks
Task ownership is enforced on every operation

Bottom Line
The REST API endpoints stay the same (GET /api/user_id/tasks, POST /api/user_id/tasks, etc.), but every request now must include a JWT token, and all responses are filtered to only include that user's data.


Monorepo Organization For Full-Stack Projects With GitHub Spec-Kit + Claude Code
This guide explains how to organize your Full-Stack Projects in a monorepo to integrate GitHub Spec-Kit for spec-driven development with Claude Code. This guide explains how to organize your repository so that Claude Code and Spec-Kit Plus can effectively edit both frontend (Next.js) and backend (FastAPI) code in a single context.
Spec-Kit Monorepo Folder Structure
hackathon-todo/
‚îú‚îÄ‚îÄ .spec-kit/                    # Spec-Kit configuration
‚îÇ   ‚îî‚îÄ‚îÄ config.yaml
‚îú‚îÄ‚îÄ specs/                        # Spec-Kit managed specifications
‚îÇ   ‚îú‚îÄ‚îÄ overview.md               # Project overview
‚îÇ   ‚îú‚îÄ‚îÄ architecture.md           # System architecture
‚îÇ   ‚îú‚îÄ‚îÄ features/                 # Feature specifications
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task-crud.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authentication.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chatbot.md
‚îÇ   ‚îú‚îÄ‚îÄ api/                      # API specifications
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rest-endpoints.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mcp-tools.md
‚îÇ   ‚îú‚îÄ‚îÄ database/                 # Database specifications
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schema.md
‚îÇ   ‚îî‚îÄ‚îÄ ui/                       # UI specifications
‚îÇ       ‚îú‚îÄ‚îÄ components.md
‚îÇ       ‚îî‚îÄ‚îÄ pages.md
‚îú‚îÄ‚îÄ CLAUDE.md                     # Root Claude Code instructions
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ CLAUDE.md
‚îÇ   ‚îî‚îÄ‚îÄ ... (Next.js app)
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ CLAUDE.md
‚îÇ   ‚îî‚îÄ‚îÄ ... (FastAPI app)
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ README.md
Key Differences from Basic Monorepo
Aspect
Without Spec-Kit
With Spec-Kit
Specs Location
/specs (flat)
/specs (organized by type)
Config File
None
/.spec-kit/config.yaml
Spec Format
Freeform markdown
Spec-Kit conventions
Referencing
@specs/file.md
@specs/features/file.md

Spec-Kit Config File
# .spec-kit/config.yaml
name: hackathon-todo
version: "1.0"
 
structure:
  specs_dir: specs
  features_dir: specs/features
  api_dir: specs/api
  database_dir: specs/database
  ui_dir: specs/ui
 
phases:
  - name: phase1-console
    features: [task-crud]
  - name: phase2-web
    features: [task-crud, authentication]
  - name: phase3-chatbot
    features: [task-crud, authentication, chatbot]

CLAUDE.md Files
Create multiple CLAUDE.md files to provide context at different levels:
Root CLAUDE.md
# Todo App - Hackathon II
 
## Project Overview
This is a monorepo using GitHub Spec-Kit for spec-driven development.
 
## Spec-Kit Structure
Specifications are organized in /specs:
- /specs/overview.md - Project overview
- /specs/features/ - Feature specs (what to build)
- /specs/api/ - API endpoint and MCP tool specs
- /specs/database/ - Schema and model specs
- /specs/ui/ - Component and page specs
 
## How to Use Specs
1. Always read relevant spec before implementing
2. Reference specs with: @specs/features/task-crud.md
3. Update specs if requirements change
 
## Project Structure
- /frontend - Next.js 14 app
- /backend - Python FastAPI server
 
## Development Workflow
1. Read spec: @specs/features/[feature].md
2. Implement backend: @backend/CLAUDE.md
3. Implement frontend: @frontend/CLAUDE.md
4. Test and iterate
 
## Commands
- Frontend: cd frontend && npm run dev
- Backend: cd backend && uvicorn main:app --reload
- Both: docker-compose up
Frontend CLAUDE.md
# Frontend Guidelines
 
## Stack
- Next.js 14 (App Router)
- TypeScript
- Tailwind CSS
 
## Patterns
- Use server components by default
- Client components only when needed (interactivity)
- API calls go through `/lib/api.ts`
 
## Component Structure
- `/components` - Reusable UI components
- `/app` - Pages and layouts
 
## API Client
All backend calls should use the api client:
 
import { api } from '@/lib/api'
const tasks = await api.getTasks()
 
## Styling
- Use Tailwind CSS classes
- No inline styles
- Follow existing component patterns

Backend CLAUDE.md
# Backend Guidelines
 
## Stack
- FastAPI
- SQLModel (ORM)
- Neon PostgreSQL
 
## Project Structure
- `main.py` - FastAPI app entry point
- `models.py` - SQLModel database models
- `routes/` - API route handlers
- `db.py` - Database connection
 
## API Conventions
- All routes under `/api/`
- Return JSON responses
- Use Pydantic models for request/response
- Handle errors with HTTPException
 
## Database
- Use SQLModel for all database operations
- Connection string from environment variable: DATABASE_URL
 
## Running
uvicorn main:app --reload --port 8000

Example Spec Files
/specs/overview.md
# Todo App Overview
 
## Purpose
A todo application that evolves from console app to AI chatbot.
 
## Current Phase
Phase II: Full-Stack Web Application
 
## Tech Stack
- Frontend: Next.js 14, TypeScript, Tailwind CSS
- Backend: FastAPI, SQLModel, Neon PostgreSQL
- Auth: Better Auth with JWT
 
## Features
- [ ] Task CRUD operations
- [ ] User authentication
- [ ] Task filtering and sorting
/specs/features/task-crud.md
# Feature: Task CRUD Operations
 
## User Stories
- As a user, I can create a new task
- As a user, I can view all my tasks
- As a user, I can update a task
- As a user, I can delete a task
- As a user, I can mark a task complete
 
## Acceptance Criteria
 
### Create Task
- Title is required (1-200 characters)
- Description is optional (max 1000 characters)
- Task is associated with logged-in user
 
### View Tasks
- Only show tasks for current user
- Display title, status, created date
- Support filtering by status

/specs/api/rest-endpoints.md
# REST API Endpoints
 
## Base URL
- Development: http://localhost:8000
- Production: https://api.example.com
 
## Authentication
All endpoints require JWT token in header:
Authorization: Bearer <token>
 
## Endpoints
 
### GET /api/tasks
List all tasks for authenticated user.
 
Query Parameters:
- status: "all" | "pending" | "completed"
- sort: "created" | "title" | "due_date"
 
Response: Array of Task objects
 
### POST /api/tasks
Create a new task.
 
Request Body:
- title: string (required)
- description: string (optional)
 
Response: Created Task object
/specs/database/schema.md
# Database Schema
 
## Tables
 
### users (managed by Better Auth)
- id: string (primary key)
- email: string (unique)
- name: string
- created_at: timestamp
 
### tasks
- id: integer (primary key)
- user_id: string (foreign key -> users.id)
- title: string (not null)
- description: text (nullable)
- completed: boolean (default false)
- created_at: timestamp
- updated_at: timestamp
 
## Indexes
- tasks.user_id (for filtering by user)
- tasks.completed (for status filtering)

Workflow with Spec-KitPlus + Claude Code
Write/Update Spec ‚Üí @specs/features/new-feature.md
Ask Claude Code to Implement ‚Üí "Implement @specs/features/new-feature.md"
Claude Code reads: Root CLAUDE.md, Feature spec, API spec, Database spec, Relevant CLAUDE.md
Claude Code implements in both frontend and backend
Test and iterate on spec if needed
Referencing Specs in Claude Code
# Implement a feature
You: @specs/features/task-crud.md implement the create task feature
 
# Implement API
You: @specs/api/rest-endpoints.md implement the GET /api/tasks endpoint
 
# Update database
You: @specs/database/schema.md add due_date field to tasks
 
# Full feature across stack
You: @specs/features/authentication.md implement Better Auth login
Summary
Component
Purpose
/.spec-kit/config.yaml
Spec-Kit configuration
/specs/<features>/**
What to build
/CLAUDE.md
How to navigate and use specs
/frontend/CLAUDE.md
Frontend-specific patterns
/backend/CLAUDE.md
Backend-specific patterns

Key Point: 
Spec-Kit Plus provides organized, structured specs that Claude Code can reference. The CLAUDE.md files tell Claude Code how to use those specs and project-specific conventions.

Summary: Monorepo vs Separate Repos
Approach
Pros
Cons
Monorepo ‚≠ê
Single CLAUDE.md context, easier cross-cutting changes
Larger repo
Separate Repos
Clear separation, independent deployments
Claude Code needs workspace setup

Recommendation: 
Use monorepo for the hackathon ‚Äì simpler for Claude Code to navigate and edit both frontend and backend in a single context.
Key Benefits of This Structure
Benefit
Description
Single Context
Claude Code sees entire project, can make cross-cutting changes
Layered CLAUDE.md
Root file for overview, subfolder files for specific guidelines
Specs Folder
Reference specifications directly with @specs/filename.md
Clear Separation
Frontend and backend code in separate folders, easy to navigate


"""Maine yeh pora project banana hai 2 steps mein. First step me mjhe iska frontend banana hai or 2nd step me main backend banana hai. Is pore project ko maine claude use krte hain speckit follow krte hue banana hai.
Seb se pehle tm mjhe is project k hisab se Agent or sub agents bana kar do phr skill bana kar do (lekn me claude free me qwen token use krte hua use kraha hn is liya mjhe agents or skill k liya sp.task ka prompt bana kar dena jise me claude ko dekh banaoga take claude . claude k folder me agents or skill ka folder bana kar sare agents or skills bana de. 
"""
Phr sp.constitution ka prompt bna kr do pore project ka
Phr sp.specify ka prompt (frontend k liya) for fronted folder structure k hisab se hona chaiya
Phr sp.plan (frontend k liya)

Is ke bad me backend k liya tmha kahuga phr sp.specify and sp.plan (backend) ka prompt likh kar dena.

Please note: 
Me tmha yeh sare prompt likhne k liya example prompt deta hn sp.consitution ka or sp.specify and sp.plan ka or agents or skill sb ka example deta hn:

Example prompt for Agents:
---
name: "section-writer"
description: "Write clear, evidence-supported research paper sections with proper citations and logical flow. Use when user asks to write a section, needs help with academic writing, or wants to structure research content."
version: "1.0.0"
---

# Section Writing Skill

## When to Use This Skill

- User asks to "write a section" or "draft content" for a research paper
- User mentions thesis, evidence integration, or academic writing
- User needs help structuring research content with citations

## How This Skill Works

1. **Outline key points**: Identify 3-5 main points the section must make
2. **Write opening paragraph**: Establish context, hook interest, connect to thesis
3. **Develop each point**: Topic sentence ‚Üí evidence/citation ‚Üí significance ‚Üí transition
4. **Write closing**: Summarize insights, connect to thesis, set up next section
5. **Quality check**: Verify claims cited, flow smooth, thesis connected

## Output Format

Provide:
- **Opening Paragraph**: Hook + context + thesis connection
- **Body Segments**: For each key point: topic sentence, evidence, significance
- **Transitions**: Smooth connections between paragraphs
- **Closing Paragraph**: Summary + thesis connection + setup for next section

## Quality Criteria

A section is ready when:
- Someone unfamiliar with topic can follow the logic
- All claims supported by evidence
- No sentences require re-reading to understand
- Opening hooks interest, closing connects to thesis

## Example

**Input**: "Write the Literature Review section on AI in K-12 education. Key points: (1) Current state of AI in K-12, (2) Teacher workload research, (3) Student outcome studies. Thesis: AI tools can measurably improve K-12 classroom efficiency."

**Output**:
- **Opening**: "The integration of artificial intelligence into K-12 classrooms represents one of the most significant shifts in educational technology since the introduction of personal computers. As schools face mounting pressure to improve outcomes while managing limited resources, AI tools offer promising solutions‚Äîbut what does the research actually show?"
- **Body**: [3 segments with topic sentences, evidence from studies, significance explained]
- **Closing**: "The evidence suggests AI tools can meaningfully reduce teacher workload while improving student engagement. However, implementation challenges and equity concerns require careful attention as districts consider adoption."

Example prompt for Skill:
I want to create a skill for writing research paper sections.

During our last session, I noticed my best sections had:
- Clear opening that establishes what the section explains
- Evidence integrated naturally, not tacked on
- Logical flow from one paragraph to the next
- Conclusions that connect back to thesis

Can you help me turn this into a reusable skill?

Example prompt of sp.constitution:
/sp.constitution

Project: Research paper on AI-native software development

Core principles:
- Accuracy through primary source verification
- Clarity for academic audience (computer science background)
- Reproducibility (all claims cited and traceable)
- Rigor (peer-reviewed sources preferred)

Key standards:
- All factual claims must be traceable to sources
- Citation format: APA style
- Source types: minimum 50% peer-reviewed articles
- Plagiarism check: 0% tolerance before submission
- Writing clarity: Flesch-Kincaid grade 10-12

Constraints:
- Word count: 5,000-7,000 words
- Minimum 15 sources
- Format: PDF with embedded citations

Success criteria:
- All claims verified against sources
- Zero plagiarism detected
- Passes fact-checking review

Example prompt for sp.specify: 
You: "I want to write a research paper on AI in K-12 education.
      What aspects should I focus on?"

AI: "Key focus areas for K-12 AI research:
     - Teacher workload reduction (grading, planning automation)
     - Student engagement improvements (adaptive learning)
     - Administrative efficiency (scheduling, resource allocation)
     - Learning outcome measurement (assessment analytics)
     Which resonates with your goals?"

You: "I'm interested in teacher workload and student outcomes.
      What would success look like for this paper?"

AI: "For a paper on those topics, success criteria might be:
     - Identifies 3+ specific AI applications with evidence
     - Cites peer-reviewed sources (8+ minimum for academic credibility)
     - Reader understands economic ROI (time saved, outcomes improved)
     - Clear enough that school administrators could act on recommendations"

You: "What constraints should I consider?"

AI: "Key constraints for academic papers:
     - Word count: 3000-5000 words is standard for this scope
     - Citation style: APA is common for education research
     - Source quality: Peer-reviewed journals, recent publications (past 10 years)
     - Scope boundaries: What you're NOT covering (ethics, specific products)"

Example prompt for Sp.plan:
/sp.plan

Create: architecture sketch, section structure, research approach, quality validation.
Decisions needing documentation: list important choices with options and tradeoffs.
Testing strategy: validation checks based on acceptance criteria.

Technical details:
- Use research-concurrent approach (research while writing, not all upfront)
- Follow APA citation style from Constitution
- Organize by phases: Research ‚Üí Foundation ‚Üí Analysis ‚Üí Synthesis
 
